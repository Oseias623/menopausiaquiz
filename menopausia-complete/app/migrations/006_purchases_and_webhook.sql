-- 1. Create table structure if it doesn't exist
CREATE TABLE IF NOT EXISTS purchases (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 2. Safely add columns if they don't exist (Bulletproof check for ALL fields)
DO $$
BEGIN
    ALTER TABLE purchases ADD COLUMN IF NOT EXISTS email TEXT;
    ALTER TABLE purchases ADD COLUMN IF NOT EXISTS product_id TEXT;
    ALTER TABLE purchases ADD COLUMN IF NOT EXISTS hotmart_product_id TEXT;
    ALTER TABLE purchases ADD COLUMN IF NOT EXISTS hotmart_transaction_code TEXT;
    ALTER TABLE purchases ADD COLUMN IF NOT EXISTS status TEXT;
    
    -- Legacy columns that might be required by constraints
    ALTER TABLE purchases ADD COLUMN IF NOT EXISTS hotmart_transaction_id TEXT;
    ALTER TABLE purchases ADD COLUMN IF NOT EXISTS purchase_date TIMESTAMP WITH TIME ZONE;
    
    -- Ensure UNIQUE constraint on transaction code
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'purchases_hotmart_transaction_code_key') THEN
        ALTER TABLE purchases ADD CONSTRAINT purchases_hotmart_transaction_code_key UNIQUE (hotmart_transaction_code);
    END IF;
END $$;

-- 3. REMOVE STRICT CONSTRAINTS (Crucial for Legacy Tables)
ALTER TABLE purchases DROP CONSTRAINT IF EXISTS purchases_status_check;

-- 4. Enable RLS
ALTER TABLE purchases ENABLE ROW LEVEL SECURITY;

-- 5. Policies
DROP POLICY IF EXISTS "Allow public read by email" ON purchases;
CREATE POLICY "Allow public read by email" ON purchases
  FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Allow service role full access" ON purchases;
CREATE POLICY "Allow service role full access" ON purchases
  FOR ALL
  USING (true)
  WITH CHECK (true);

-- 6. Indexes
CREATE INDEX IF NOT EXISTS idx_purchases_email ON purchases(email);
CREATE INDEX IF NOT EXISTS idx_purchases_transaction ON purchases(hotmart_transaction_code);

-- 7. Function to process Hotmart Webhook (UPDATED for Constraints)
CREATE OR REPLACE FUNCTION process_hotmart_webhook(p_webhook_data JSONB)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_transaction TEXT;
  v_status TEXT;
  v_email TEXT;
  v_product_id TEXT;
  v_result JSONB;
BEGIN
  v_transaction := p_webhook_data->'data'->'purchase'->>'transaction';
  v_status := p_webhook_data->'data'->'purchase'->>'status';
  v_email := p_webhook_data->'data'->'buyer'->>'email';
  v_product_id := p_webhook_data->'data'->'product'->>'id';
  
  -- Clean email
  v_email := LOWER(TRIM(v_email));

  -- Insert with ALL required legacy columns and Fallbacks
  INSERT INTO purchases (
    email, 
    hotmart_product_id, 
    hotmart_transaction_code, 
    status, 
    updated_at,
    product_id,             -- Legacy Field
    hotmart_transaction_id, -- Legacy Field
    purchase_date           -- Legacy Field
  )
  VALUES (
    v_email, 
    v_product_id, 
    v_transaction, 
    v_status, 
    NOW(),
    COALESCE(v_product_id, 'UNKNOWN'), -- Fallback
    v_transaction,                     -- Reuse transaction as ID
    NOW()                              -- Current time
  )
  ON CONFLICT (hotmart_transaction_code)
  DO UPDATE SET
    status = EXCLUDED.status,
    email = EXCLUDED.email,
    updated_at = NOW();

  v_result := jsonb_build_object('success', true, 'action', 'upsert');
  RETURN v_result;
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;
